# William Wadsworth
# Created: 7.22.2024
# Initial release: 7.28.2024
# 
# This script is Jeopardy with Trivia questions via the Trivia API from Open Trivia Database
# (documentation: https://opentdb.com/api_config.php). Notes about use of the API will be found in
# the documentation, and a simple demonstration can be found in trivia.py. Debug output is labeled
# with '--'. An internet connection is required for the program to work.
# 
# Usage: python3 jeopardy.py
# 
# Planned potential features:
# - token persistence
# - timer
# - sound effects?
# - tab autocomplete?

from requests import get
from random import sample, shuffle
from html import unescape
from typing import Tuple, List

DEBUG: bool = False
ANSWER_TIME: int = 30

# --- API TOKEN HANDLING ------------------------

# This function generates an API token for consistently new questions
# pre-condition: an internet connection
# post-condition: returns the token generated by the API
def generateSessionToken() -> str:
    if DEBUG:
        print("--Entering generateSessionToken...")
        
    response = get("https://opentdb.com/api_token.php?command=request")
    
    if response.status_code == 200:
        data = response.json()
        if data['response_code'] == 0:
            if DEBUG:
                print("--Exiting generateSessionToken.")
            return data['token']
        else:
            raise ValueError(f"Error in resetting token: {data['response_message']}")
    else:
        raise ConnectionError(f"HTTP Error: {response.status_code}")


# This function resets the API token after all questions have been used
# pre-condition: an internet connection
# post-condition: returns the re-generated token by the API
def resetToken() -> str:
    if DEBUG:
        print("--Entering resetToken...")
        
    response = get(f"https://opentdb.com/api_token.php?command=reset&token={API_TOKEN}")
    
    if response.status_code == 200:
        data = response.json()
        if data['response_code'] == 0:
            if DEBUG:
                print("--Exiting resetToken.")
            return data['token']
        else:
            raise ValueError(f"Error in resetting token: {data['response_message']}")
    else:
        raise ConnectionError(f"HTTP Error: {response.status_code}")


API_TOKEN: str = generateSessionToken()
if DEBUG:
    print(f"--API token: {API_TOKEN}")
    
# Note that with this current setup, the token will be generated each time the program is run, so
# essentially the token will not be used to its extent if the user wants to re-run the program. Its
# inclusion here is more so for redundancy, and for possibly future updates.

# --- LIBRARY -----------------------------------

class Team:
    def __init__(self, name: str) -> None:
        self.name = name
        self.score = 0

    # this function updates a team's score
    # pre-condition: points must be initialized to a non-negative integer
    # post-condition: adds the specified points to the team's score
    def update_score(self, points: int) -> None:
        self.score += points

    def __str__(self) -> str:
        return f"{self.name}: {self.score} points"


# This function outputs the current jeopardy board
# pre-condition: none
# post-condition: the current jeopardy board is printed
def displayTable() -> None:
    if DEBUG:
        print("--Entering displayTable...")
        
    # calculate the width for each column (including padding)
    minimum_space: int = 8
    column_widths = [max(len(name), minimum_space)+4 for name in selected_category_names]
    
    # header
    header = "|".join([f" {name:^{column_widths[i]-2}} " for i, name in enumerate(selected_category_names)])
    print(f"|{header}|")
    
    # separator
    print("-" * (len(header) + len(selected_category_names) - 4))
    
    # display each row of the table
    for row in zip(*table):
        row_display = "|".join([f" {item:^{column_widths[i]-2}} " for i, item in enumerate(row)])
        print(f"|{row_display}|")
    
    if DEBUG:
        print("--Exiting displayTable.")


# This function updates the board by replacing a question with whitespace
# pre-condition: category must be initialized as a string representing a valid category, value must
#                be initialized to a positive, non-negative integer representing a valid question
#                value
# post-condition: the question index in the board is replaced with whitespace
def updateTable(category: str, value: int) -> None:
    if DEBUG:
        print("--Entering updateTable...")
        
    col_index = selected_category_names.index(category)
    row_index = monetary_values.index(value)
    table[col_index][row_index] = " "
    
    if DEBUG:
        print("--Exiting updateTable.")


# This function queries the API for a trivia question (NOTE: removed T/F functionality due to
# gauranteed answers when stealing)
# pre-condition: category must be initialized as a string, question_amount must be initialized to a
#                number [9,32], API_TOKEN must be initialized to a valid API token
# post-condition: a tuple containing the question (string), the correct answer (string), and a list
#                 of three incorrect answers (list of strings)
def getQuestion(category: int, question_amount: int) -> Tuple[str, str, List[str]]:
    # basically from trivia.py
    if DEBUG:
        print(f"--Entering getQuestion...\nCat {category}, ${question_amount}")
    
    # ensure correct scope
    global API_TOKEN
    
    # init API URL var
    api_url: str = f'https://opentdb.com/api.php?amount=1&token={API_TOKEN}&category={category}&type=multiple'
    
    # check question difficulty, update difficulty
    match (question_amount):
        case 100:
            api_url += f'&difficulty=easy'
        case 200, 300:
            api_url += f'&difficulty=medium'
        case 400, 500:
            api_url += f'&difficulty=hard'

    # query the API
    if DEBUG:
        print(f"--API URL: {api_url}")
    response = get(api_url)
    
    if response.status_code == 200:
        data = response.json()
        
        # extract the question and answers from the response
        if data['response_code'] == 0:
            question_data = data['results'][0]
            question = question_data['question']
            correct_answer = question_data['correct_answer']
            incorrect_answers = question_data['incorrect_answers']
            
            # convert any HTML entities to their characters
            question = unescape(question)
            correct_answer = unescape(correct_answer)
            incorrect_answers = [unescape(ans) for ans in incorrect_answers]
            
            if DEBUG:
                print("--Exiting getQuestion.")
            return question, correct_answer, incorrect_answers
        # reset token after all questions used
        elif data['response_code'] == 4:
            API_TOKEN = resetToken()
        else:
            raise ValueError(f"API response error {data['response_code']}")
    else:
        raise ValueError(f"Failed to fetch question from API ({response.status_code})")


# This function outputs the current team scores
# pre-condition: none
# post-condition: each team name and score is output
def displayScores() -> None:
    if DEBUG:
        print("--Entering displayScores...")
        
    for team in teams:
        print(team)
    
    if DEBUG:
        print("--Exiting displayScores.")


# This helper function checks if all questions have been answered 
# pre-condition: none
# post-condition: True is returned if every question on the board is whitespace, otherwise False is
#                 returned
def allQuestionsAnswered() -> bool:
    return all(item == " " for row in table for item in row)


# This helper function switches team indices 
# pre-condition: current_index must be initialized to a positive, non-negative integer
# post-condition: returns the index of the next team
def switchTeam(current_index: int) -> int:
    return (current_index + 1) % len(teams)


# --- MAIN ----------------------------------------------------------------------------------------
# --- TEAM NAMES --------------------------------

# get team names from user
team_names = [input(f"Enter Team {i+1}'s name: ") for i in range(2)]
# convert to Team object
teams = [Team(name) for name in team_names]

# --- CATEGORIES AND VARIABLES ------------------

# pick 6 random numbers from the range 9-32
MAX_CATEGORIES = 6
selected_categories = sample(list(range(9,33)), MAX_CATEGORIES)
# list of categories and their numerical pairing for the API call
category_names = {
    9: "General Knowledge",
    10: "Books",
    11: "Film",
    12: "Music",
    13: "Musicals & Theatres",
    14: "Television",
    15: "Video Games",
    16: "Board Games",
    17: "Science & Nature",
    18: "Computers",
    19: "Mathematics",
    20: "Mythology",
    21: "Sports",
    22: "Geography",
    23: "History",
    24: "Politics",
    25: "Art",
    26: "Celebrities",
    27: "Animals",
    28: "Vehicles",
    29: "Comics",
    30: "Gadgets",
    31: "Japanese Anime & Manga",
    32: "Cartoon & Animation"
}

# create a reverse mapping for API call
name_to_number = {v: k for k, v in category_names.items()}

# load selected categories into list
selected_category_names = [category_names[num] for num in selected_categories]

# var for each level of question
monetary_values = [100,200,300,400,500]

# --- TABLE CREATION ----------------------------

# init with monetary values for each category
table = [[f"${value}" for value in monetary_values] for _ in selected_category_names]

# --- MAIN LOOP -----------------------------------------------------------------------------------

# get the first team
#current_team: str = input("Enter the team to go first: ")
current_team_index = team_names.index(input("Enter the team to go first: "))

displayTable()

while not allQuestionsAnswered():
    current_team = teams[current_team_index]
    print(f"\nIt's {current_team.name}'s turn.")

    # --- CATEGORY SELECTION --------------------
    # select category and question 
    try:
        selection_category, selection_question = input("Select a category and question: ").rsplit(' ', 1)
        selection_question = int(selection_question)
        # check int selection
        while selection_question not in monetary_values:
            selection_question = int(input("Please enter 100, 200, 300, 400, or 500: "))
    except ValueError:
        print("Invalid, please enter the category and question in the format 'category question'.")
        continue
    # input validation
    if selection_category not in selected_category_names or selection_question not in monetary_values:
        print("Invalid category or question value. Please try again.")
        continue
    
    # check if the question is already answered, input validation
    col_index = selected_category_names.index(selection_category)
    row_index = monetary_values.index(selection_question)
    if table[col_index][row_index] == " ":
        print("This question has already been answered. Please select another.")
        continue
    
    # --- API CALL ------------------------------
    # fetch question and answers from API
    try:
        category_number = name_to_number[selection_category]
        question, correct_answer, incorrect_answers = getQuestion(category_number,selection_question)
    except ValueError as e:
        print(e)
        continue
    
    # group all answers
    all_answers = incorrect_answers + [correct_answer]
    # mix answers
    shuffle(all_answers)
    
    # Display the question and answers
    #print(f"\nQuestion: {question}")
    print(f"\n  --- {selection_category} - ${selection_question} ---\n{question}")
    for i, answer in enumerate(all_answers, 1):
        print(f"{i}. {answer}")
    
    # --- ANSWERING -----------------------------
    # get the team's answer
    team_answer = input("\n: ")
    
    # validate and update the score
    if team_answer.isdigit() and int(team_answer) in range(1, len(all_answers) + 1):
        if all_answers[int(team_answer) - 1] == correct_answer:
            print("Correct!")
            current_team.update_score(selection_question)
        # other team steal
        else:
            print("Incorrect.")
            
            # switch to other team for a chance to steal
            other_team_index = switchTeam(current_team_index)
            other_team = teams[other_team_index]
            print(f"\nIt's {other_team.name}'s chance to steal.")

            # get other team's answer
            team_answer = input("\n: ")
            
            # validate and update the score for the other team
            if team_answer.isdigit() and int(team_answer) in range(1, len(all_answers) + 1):
                if all_answers[int(team_answer) - 1] == correct_answer:
                    print("Correct!")
                    other_team.update_score(selection_question)
                else:
                    print("Incorrect.")
            elif team_answer == 0:
                print("Time's up.")
            else:
                print("Invalid answer. Please enter a valid number.")
    else:
        print("Time's up.")
            
        # switch to other team for a chance to steal
        other_team_index = switchTeam(current_team_index)
        other_team = teams[other_team_index]
        print(f"\nIt's {other_team.name}'s chance to steal.")

        # get other team's answer
        team_answer = input("\n: ")
        
        # validate and update the score for the other team
        if team_answer.isdigit() and int(team_answer) in range(1, len(all_answers) + 1):
            if all_answers[int(team_answer) - 1] == correct_answer:
                print("Correct!")
                other_team.update_score(selection_question)
            else:
                print("Incorrect.")
        elif team_answer == 0:
            print("Time's up.")
        else:
            print("Invalid answer. Please enter a valid number.")
    
    # Update the table to mark the question as answered
    updateTable(selection_category, selection_question)
    
    # switch team index to next team
    current_team_index = (current_team_index + 1) % len(teams)
    
    # show updated scores
    displayScores()
    
    print()
    displayTable()


print("\n\nFINAL SCORES:")
displayScores()

