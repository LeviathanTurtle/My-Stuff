# William Wadsworth
# Created: 7.22.2024
# Initial release: 7.28.2024
# Updated 8.16.2024: PEP 8 Compliance
# Updated 8.24.2024: added token persistence via external file
# 
# This script is Jeopardy with Trivia questions via the Trivia API from Open Trivia Database
# (documentation: https://opentdb.com/api_config.php). Notes about use of the API will be found in
# the documentation, and a simple demonstration can be found in trivia.py. Debug output is labeled
# with '--'. An internet connection is required for the program to work.
# 
# Usage: python3 jeopardy.py [-token <filename>]
# where:
#     -token: optional, file containing the API token. If provided, the filename must also be
#             provided following the flag
# 
# Potential planned features:
# - timer
# - sound effects?
# - tab autocomplete?

from sys import argv, stderr, exit
from requests import get
from random import sample, shuffle
from html import unescape
from typing import Tuple, List, Optional

DEBUG: bool = False
API_TOKEN: str = ""
#ANSWER_TIME: int = 30

# --- API TOKEN HANDLING ------------------------

# pre-condition: an internet connection
# post-condition: returns the token generated by the API
def get_session_token(token_filename: Optional[str] = None) -> str:
    """Generate a new session token for the trivia API."""
    
    if DEBUG:
        print("--Entering get_session_token...")
        
    file_token: Optional[str] = None
        
    if token_filename is not None:
        try:
            # file stuff
            with open(token_filename, 'r') as file:
                file_token = file.read().strip()
        except FileNotFoundError:
            print(f"Warning: file '{token_filename}' not found. Generating a new token")
    
    # return the token from the file if it was read
    if file_token:
        # dump to file
        dump_token(file_token)
        if DEBUG:
            print("--Exiting get_session_token.")
        return file_token
    
    # otherwise, assume we still need a token, so generate a new one
    response = get("https://opentdb.com/api_token.php?command=request")
    
    if response.status_code == 200:
        data = response.json()
        if data['response_code'] == 0:
            dump_token(data['token'])
            if DEBUG:
                print("--Exiting get_session_token.")
            return data['token']
        else:
            raise ValueError(f"Error in resetting token: {data['response_message']}")
    else:
        raise ConnectionError(f"HTTP Error: {response.status_code}")


# pre-condition: an internet connection, api_token must be initialized as a string representing the
#                API token
# post-condition: returns the re-generated token by the API
def reset_token(api_token: str) -> str:
    """Reset the session token."""
    
    if DEBUG:
        print("--Entering reset_token...")
        
    response = get(f"https://opentdb.com/api_token.php?command=reset&token={api_token}")
    
    if response.status_code == 200:
        data = response.json()
        if data['response_code'] == 0:
            if DEBUG:
                print("--Exiting reset_token.")
            return data['token']
        else:
            raise ValueError(f"Error in resetting token: {data['response_message']}")
    else:
        raise ConnectionError(f"HTTP Error: {response.status_code}")


# pre-condition: api_token must be initialized as a string representing the API token
# post-condition: outputs the API token to a file named 'token'
def dump_token(api_token: str) -> None:
    """Dumps the API token to an external file."""
    
    if DEBUG:
        print("--Entering dump_token...")
        
    try:
        with open("token",'w') as file:
            file.write(api_token)
            if DEBUG:
                print("Dumped API token to filename 'token'")
    except IOError as e:
        print(f"Error dumping API token (Error: {e})")
        
    if DEBUG:
        print("--Exiting dump_token.")


# --- LIBRARY -----------------------------------

class Team:
    def __init__(self, name: str) -> None:
        """Represents a trivia team."""
        self.name = name
        self.score = 0

    # pre-condition: points must be initialized to a non-negative integer
    # post-condition: adds the specified points to the team's score
    def update_score(self, points: int) -> None:
        """Update the team's score by the given points."""
        self.score += points

    def __str__(self) -> str:
        return f"{self.name}: {self.score} points"


# pre-condition: none
# post-condition: the current jeopardy board is printed
def display_table(selected_category_names: List[str], table: List[List[str]]) -> None:
    """Display the current state of the trivia table."""
    
    if DEBUG:
        print("--Entering display_table...")
    
    # calculate the width for each column (including padding)
    minimum_space: int = 8
    column_widths = [max(len(name), minimum_space)+4 for name in selected_category_names]
    
    # header
    header = "|".join([f" {name:^{column_widths[i]-2}} " for i, name in enumerate(selected_category_names)])
    print(f"|{header}|")
    
    # separator
    print("-" * (len(header) + len(selected_category_names) - 4))
    
    # display each row of the table
    for row in zip(*table):
        row_display = "|".join([f" {item:^{column_widths[i]-2}} " for i, item in enumerate(row)])
        print(f"|{row_display}|")
    
    if DEBUG:
        print("--Exiting display_table.")


# pre-condition: category must be initialized as a string representing a valid category, value must
#                be initialized to a positive, non-negative integer representing a valid question
#                value
# post-condition: the question index in the board is replaced with whitespace
def update_table(table: List[List[str]], category: str, value: int, selected_category_names: List[str], monetary_values: List[int]) -> None:
    """Update the trivia table by marking a question as answered."""
    
    if DEBUG:
        print("--Entering update_table...")
    
    col_index = selected_category_names.index(category)
    row_index = monetary_values.index(value)
    table[col_index][row_index] = " "
    
    if DEBUG:
        print("--Exiting update_table.")


# pre-condition: category must be initialized as a string, question_amount must be initialized to a
#                number [9,32], API_TOKEN must be initialized to a valid API token
# post-condition: a tuple containing the question (string), the correct answer (string), and a list
#                 of three incorrect answers (list of strings)
def get_question(category: int, question_amount: int) -> Tuple[str, str, List[str]]:
    """Fetch a trivia question from the API."""
    
    # basically from trivia.py
    if DEBUG:
        print(f"--Entering getQuestion...\nCat {category}, ${question_amount}")
    
    # ensure correct scope
    global API_TOKEN
    
    # init API URL var
    api_url: str = f'https://opentdb.com/api.php?amount=1&token={API_TOKEN}&category={category}&type=multiple'
    
    # check question difficulty, update difficulty
    if question_amount == 100:
        api_url += '&difficulty=easy'
    elif question_amount in [200, 300]:
        api_url += '&difficulty=medium'
    elif question_amount in [400, 500]:
        api_url += '&difficulty=hard'

    if DEBUG:
        print(f"--API URL: {api_url}")
        
    # this is just for if the token needs to be reset, a question will still be returned
    while True:
        # query the API
        response = get(api_url)
        
        if response.status_code == 200:
            data = response.json()
            
            # extract the question and answers from the response
            if data['response_code'] == 0:
                question_data = data['results'][0]
                # separate response into respective vars, also convert any HTML entities to their
                # characters
                question = unescape(question_data['question'])
                correct_answer = unescape(question_data['correct_answer'])
                incorrect_answers = [unescape(ans) for ans in question_data['incorrect_answers']]
                
                if DEBUG:
                    print("--Exiting getQuestion.")
                return question, correct_answer, incorrect_answers
            # reset token if all questions used
            elif data['response_code'] == 4:
                API_TOKEN = reset_token(API_TOKEN)
            else:
                raise ValueError(f"API response error {data['response_code']}")
        else:
            raise ValueError(f"Failed to fetch question from API ({response.status_code})")


# pre-condition: none
# post-condition: each team name and score is output
def display_scores(teams: List[Team]) -> None:
    """Display the current scores of all teams."""
    
    if DEBUG:
        print("--Entering display_scores...")
    
    for team in teams:
        print(team)
    
    if DEBUG:
        print("--Exiting display_scores.")


# pre-condition: none
# post-condition: True is returned if every question on the board is whitespace, otherwise False is
#                 returned
def all_questions_answered(table: List[List[str]]) -> bool:
    """Check if all questions have been answered."""
    
    return all(item == " " for row in table for item in row)


# pre-condition: current_index must be initialized to a positive, non-negative integer
# post-condition: returns the index of the next team
def switch_team(current_index: int, total_teams: int) -> int:
    """Switch to the next team."""
    
    return (current_index + 1) % total_teams


def main():
    # check CLI args
    if len(argv) < 3:
        stderr.write("Usage: python3 jeopardy.py [-token <filename>]")
        exit(1)
    
    # if there are 3 args
    if len(argv) == 3:
        # then we know the third is the filename
        API_TOKEN = get_session_token(argv[2])
    else:
        # otherwise make a new token
        API_TOKEN = get_session_token()
    if DEBUG:
        print(f"--API token: {API_TOKEN}")
    
    # get team names from user
    team_names = [input(f"Enter Team {i+1}'s name: ") for i in range(2)]
    # convert to Team object
    teams = [Team(name) for name in team_names]

    # --- CATEGORIES AND VARIABLES --------------

    # pick 6 random numbers from the range 9-32
    MAX_CATEGORIES: int = 6
    selected_categories = sample(list(range(9,33)), MAX_CATEGORIES)
    # list of categories and their numerical pairing for the API call
    category_names = {
        9: "General Knowledge",
        10: "Books",
        11: "Film",
        12: "Music",
        13: "Musicals & Theatres",
        14: "Television",
        15: "Video Games",
        16: "Board Games",
        17: "Science & Nature",
        18: "Computers",
        19: "Mathematics",
        20: "Mythology",
        21: "Sports",
        22: "Geography",
        23: "History",
        24: "Politics",
        25: "Art",
        26: "Celebrities",
        27: "Animals",
        28: "Vehicles",
        29: "Comics",
        30: "Gadgets",
        31: "Japanese Anime & Manga",
        32: "Cartoon & Animation"
    }

    # create a reverse mapping for API call
    name_to_number = {v: k for k, v in category_names.items()}

    # load selected categories into list
    selected_category_names = [category_names[num] for num in selected_categories]

    # var for each level of question
    monetary_values = [100,200,300,400,500]

    # --- TABLE CREATION ------------------------

    # init with monetary values for each category
    table = [[f"${value}" for value in monetary_values] for _ in selected_category_names]

    # --- MAIN LOOP -------------------------------------------------------------------------------

    # get the first team
    #current_team: str = input("Enter the team to go first: ")
    current_team_index = team_names.index(input("Enter the team to go first: "))

    display_table(selected_category_names, table)

    while not all_questions_answered(table):
        current_team = teams[current_team_index]
        print(f"\nIt's {current_team.name}'s turn.")

        # --- CATEGORY SELECTION ----------------
        # select category and question 
        try:
            selection_category, selection_question = input("Select a category and question: ").rsplit(' ', 1)
            selection_question = int(selection_question)
            # check int selection
            while selection_question not in monetary_values:
                selection_question = int(input("Please enter 100, 200, 300, 400, or 500: "))
        except ValueError:
            print("Invalid, please enter the category and question in the format 'category question'.")
            continue
        # input validation
        if selection_category not in selected_category_names or selection_question not in monetary_values:
            print("Invalid category or question value. Please try again.")
            continue
        
        # check if the question is already answered, input validation
        col_index = selected_category_names.index(selection_category)
        row_index = monetary_values.index(selection_question)
        if table[col_index][row_index] == " ":
            print("This question has already been answered. Please select another.")
            continue
        
        # --- API CALL --------------------------
        # fetch question and answers from API
        try:
            category_number = name_to_number[selection_category]
            question, correct_answer, incorrect_answers = get_question(category_number,selection_question)
        except ValueError as e:
            print(e)
            continue
        
        # group all answers
        all_answers = incorrect_answers + [correct_answer]
        # mix answers
        shuffle(all_answers)
        
        # display the question and answers
        print(f"\n  --- {selection_category} - ${selection_question} ---\n{question}")
        for i, answer in enumerate(all_answers, 1):
            print(f"{i}. {answer}")
        
        # --- ANSWERING -------------------------
        # get the team's answer
        team_answer = input("\n: ")
        
        # validate and update the score
        if team_answer.isdigit() and int(team_answer) in range(1, len(all_answers) + 1):
            if all_answers[int(team_answer) - 1] == correct_answer:
                print("Correct!")
                current_team.update_score(selection_question)
            # other team steal
            else:
                print("Incorrect.")
                
                # switch to other team for a chance to steal
                other_team_index = switch_team(current_team_index, len(teams))
                other_team = teams[other_team_index]
                print(f"\nIt's {other_team.name}'s chance to steal.")

                # get other team's answer
                team_answer = input("\n: ")
                
                # validate and update the score for the other team
                if team_answer.isdigit() and int(team_answer) in range(1, len(all_answers) + 1):
                    if all_answers[int(team_answer) - 1] == correct_answer:
                        print("Correct!")
                        other_team.update_score(selection_question)
                    else:
                        print("Incorrect.")
                else:
                    print("Invalid answer. Please enter a valid number.")
        # user entered invalid response
        else:
            print("Invalid answer.")
                
            # switch to other team for a chance to steal
            other_team_index = switch_team(current_team_index)
            other_team = teams[other_team_index]
            print(f"\nIt's {other_team.name}'s chance to steal.")

            # get other team's answer
            team_answer = input("\n: ")
            
            # validate and update the score for the other team
            if team_answer.isdigit() and int(team_answer) in range(1, len(all_answers) + 1):
                if all_answers[int(team_answer) - 1] == correct_answer:
                    print("Correct!")
                    other_team.update_score(selection_question)
                else:
                    print("Incorrect.")
            else:
                print("Invalid answer. Please enter a valid number.")
        
        # update the table to mark the question as answered
        update_table(table, selection_category, selection_question, selected_category_names, monetary_values)
        
        # switch team index to next team
        current_team_index = (current_team_index + 1) % len(teams)
        
        # show updated scores
        display_scores(teams)
        print()
        display_table(selected_category_names, table)

    print("\n\nFINAL SCORES:")
    display_scores(teams)


if __name__ == "__main__":
    main()